package com.mapswithme.maps.analytics

import android.app.Application
import android.os.AsyncTask
import android.os.CountDownTimer
import android.text.TextUtils
import androidx.annotation.UiThread
import com.appsflyer.AppsFlyerConversionListener
import com.appsflyer.AppsFlyerLib
import com.crashlytics.android.Crashlytics
import com.crashlytics.android.core.CrashlyticsCore
import com.crashlytics.android.ndk.CrashlyticsNdk
import com.google.android.gms.ads.identifier.AdvertisingIdClient
import com.google.android.gms.common.GooglePlayServicesNotAvailableException
import com.google.android.gms.common.GooglePlayServicesRepairableException
import com.mapswithme.maps.BuildConfig
import com.mapswithme.maps.Framework
import com.mapswithme.maps.Framework.nativeMoPubInitializationBannerId
import com.mapswithme.maps.MwmApplication
import com.mapswithme.maps.PrivateVariables.appsFlyerKey
import com.mapswithme.maps.R
import com.mapswithme.maps.ads.Banner
import com.mapswithme.maps.analytics.AppsFlyerUtils.getDeepLink
import com.mapswithme.maps.analytics.AppsFlyerUtils.isFirstLaunch
import com.mapswithme.util.CrashlyticsUtils.logException
import com.mapswithme.util.PermissionsUtils.isLocationGranted
import com.mapswithme.util.Utils.installationId
import com.mapswithme.util.concurrency.UiThread.isUiThread
import com.mapswithme.util.log.LoggerFactory
import com.mapswithme.util.log.LoggerFactory.Companion.INSTANCE
import com.mopub.common.MoPub
import com.mopub.common.SdkConfiguration
import com.my.target.common.MyTargetPrivacy
import io.fabric.sdk.android.Fabric
import java.io.IOException
import java.util.*
import java.util.concurrent.TimeoutException

class ExternalLibrariesMediator(val application: Application) {
    var isCrashlyticsInitialized = false
        private set
    @Volatile
    var eventLogger: EventLogger
        private set
    private var mEventLoggerInitialized = false
    private var mAdvertisingInfo: AdvertisingInfo? =
        null
    private var mFirstLaunchDeepLink: String? = null
    private val mAdvertisingObservers: MutableList<AdvertisingObserver> =
        ArrayList()

    fun initSensitiveDataToleranceLibraries() {
        initMoPub()
        initCrashlytics()
        initAppsFlyer()
    }

    fun initSensitiveDataStrictLibrariesAsync() {
        val getAdInfoTask = GetAdInfoTask(this)
        getAdInfoTask.execute()
    }

    private fun initSensitiveEventLogger() {
        check(isUiThread) { "Must be call from Ui thread" }
        if (mEventLoggerInitialized) return
        eventLogger = EventLoggerAggregator(application)
        eventLogger.initialize()
        mEventLoggerInitialized = true
    }

    private fun initAppsFlyer() {
        AppsFlyerLib.getInstance()
            .init(appsFlyerKey(), FirstLaunchDeeplinkListener())
        AppsFlyerLib.getInstance().setDebugLog(BuildConfig.DEBUG)
        AppsFlyerLib.getInstance().setResolveDeepLinkURLs()
        AppsFlyerLib.getInstance().startTracking(application)
    }

    fun initCrashlytics() {
        if (!isCrashlyticsEnabled) return
        if (isCrashlyticsInitialized) return
        val core = Crashlytics.Builder()
            .core(CrashlyticsCore.Builder().disabled(!isFabricEnabled).build())
            .build()
        Fabric.with(application, core, CrashlyticsNdk())
        nativeInitCrashlytics()
        isCrashlyticsInitialized = true
    }

    val isCrashlyticsEnabled: Boolean
        get() = false

    private val isFabricEnabled: Boolean
        private get() {
            val prefKey =
                application.resources.getString(R.string.pref_opt_out_fabric_activated)
            return MwmApplication.prefs(application).getBoolean(prefKey, true)
        }

    fun setInstallationIdToCrashlytics(): Boolean {
        if (!isCrashlyticsEnabled) return false
        val installationId = installationId
        // If installation id is not found this means id was not
// generated by alohalytics yet and it is a first run.
        if (TextUtils.isEmpty(installationId)) return false
        Crashlytics.setString("AlohalyticsInstallationId", installationId)
        return true
    }

    private fun initMoPub() {
        val sdkConfiguration =
            SdkConfiguration.Builder(nativeMoPubInitializationBannerId())
                .build()
        MoPub.initializeSdk(application, sdkConfiguration, null)
        val manager = MoPub.getPersonalInformationManager()
        manager?.grantConsent()
    }

    @UiThread
    private fun setAdvertisingInfo(info: AdvertisingInfo) {
        mAdvertisingInfo = info
    }

    @UiThread
    private fun notifyObservers() {
        for (observer in mAdvertisingObservers) observer.onAdvertisingInfoObtained()
    }

    @get:UiThread
    val isAdvertisingInfoObtained: Boolean
        get() = mAdvertisingInfo != null

    @get:UiThread
    val isLimitAdTrackingEnabled: Boolean
        get() {
            checkNotNull(mAdvertisingInfo) { "Advertising info must be obtained first!" }
            return mAdvertisingInfo!!.isLimitAdTrackingEnabled
        }

    fun disableAdProvider(type: Banner.Type) {
        Framework.disableAdProvider(type)
        MyTargetPrivacy.setUserConsent(false)
    }

    @UiThread
    fun initSensitiveData() {
        initSensitiveEventLogger()
        if (isLocationGranted(application)) return
        MyTargetPrivacy.setUserConsent(false)
    }

    fun retrieveFirstLaunchDeeplink(): String? {
        val firstLaunchDeepLink = mFirstLaunchDeepLink
        mFirstLaunchDeepLink = null
        return firstLaunchDeepLink
    }

    fun addAdvertisingObserver(observer: AdvertisingObserver) {
        mAdvertisingObservers.add(observer)
    }

    fun removeAdvertisingObserver(observer: AdvertisingObserver) {
        mAdvertisingObservers.remove(observer)
    }

    private inner class FirstLaunchDeeplinkListener : AppsFlyerConversionListener {
        override fun onInstallConversionDataLoaded(conversionData: Map<String, String>) {
            if (conversionData == null || conversionData.isEmpty()) return
            for (attrName in conversionData.keys) {
                LOGGER.d(
                    TAG,
                    "onInstallConversion attribute: " + attrName + " = "
                            + conversionData[attrName]
                )
            }
            if (!isFirstLaunch(conversionData)) return
            mFirstLaunchDeepLink = getDeepLink(conversionData)
        }

        override fun onInstallConversionFailure(errorMessage: String) {
            LOGGER.e(
                TAG,
                "onInstallConversionFailure: $errorMessage"
            )
        }

        override fun onAppOpenAttribution(conversionData: Map<String, String>) {
            if (conversionData == null || conversionData.isEmpty()) return
            for (attrName in conversionData.keys) {
                LOGGER.d(
                    TAG,
                    "onAppOpenAttribution attribute: " + attrName + " = "
                            + conversionData[attrName]
                )
            }
        }

        override fun onAttributionFailure(errorMessage: String) {
            LOGGER.d(
                TAG,
                "onAttributionFailure: $errorMessage"
            )
        }
    }

    internal class GetAdInfoTask(private val mMediator: ExternalLibrariesMediator) :
        AsyncTask<Void, Void, AdvertisingInfo>() {
        private val mTimer: CountDownTimer = object : CountDownTimer(
            ADS_INFO_GETTING_TIMEOUT_MS,
            ADS_INFO_GETTING_CHECK_INTERVAL_MS
        ) {
            override fun onTick(millisUntilFinished: Long) {
                if (status == Status.FINISHED) {
                    LOGGER.i(
                        TAG,
                        "Timer could be cancelled, advertising id already obtained"
                    )
                    cancel()
                }
            }

            override fun onFinish() {
                if (status == Status.FINISHED) return
                LOGGER.w(
                    TAG,
                    "Cancel getting advertising id request, timeout exceeded."
                )
                this@GetAdInfoTask.cancel(true)
                mMediator.setAdvertisingInfo(
                    AdvertisingInfo(
                        null
                    )
                )
                mMediator.notifyObservers()
            }
        }

        override fun onPreExecute() {
            super.onPreExecute()
            mTimer.start()
        }

        protected override fun doInBackground(vararg voids: Void): AdvertisingInfo {
            return try {
                val application = mMediator.application
                LOGGER.i(
                    TAG,
                    "Start of getting advertising info"
                )
                val info =
                    AdvertisingIdClient.getAdvertisingIdInfo(application)
                if (isCancelled) {
                    val msg =
                        "Advertising id wasn't obtained within $ADS_INFO_GETTING_TIMEOUT_MS ms"
                    LOGGER.w(
                        TAG,
                        msg
                    )
                    throw TimeoutException(msg)
                }
                LOGGER.i(
                    TAG,
                    "End of getting advertising info"
                )
                AdvertisingInfo(info)
            } catch (e: GooglePlayServicesNotAvailableException) {
                LOGGER.e(
                    TAG,
                    "Failed to obtain advertising id: ",
                    e
                )
                logException(e)
                AdvertisingInfo(null)
            } catch (e: IOException) {
                LOGGER.e(
                    TAG,
                    "Failed to obtain advertising id: ",
                    e
                )
                logException(e)
                AdvertisingInfo(null)
            } catch (e: GooglePlayServicesRepairableException) {
                LOGGER.e(
                    TAG,
                    "Failed to obtain advertising id: ",
                    e
                )
                logException(e)
                AdvertisingInfo(null)
            } catch (e: TimeoutException) {
                LOGGER.e(
                    TAG,
                    "Failed to obtain advertising id: ",
                    e
                )
                logException(e)
                AdvertisingInfo(null)
            }
        }

        override fun onPostExecute(info: AdvertisingInfo) {
            LOGGER.i(
                TAG,
                "onPostExecute, info: $info"
            )
            super.onPostExecute(info)
            mMediator.setAdvertisingInfo(info)
            mMediator.notifyObservers()
        }

        override fun onCancelled() {
            LOGGER.i(
                TAG,
                "onCancelled"
            )
            super.onCancelled()
        }

        companion object {
            private const val ADS_INFO_GETTING_TIMEOUT_MS: Long = 4000
            private const val ADS_INFO_GETTING_CHECK_INTERVAL_MS: Long = 500
        }

    }

    internal class AdvertisingInfo(private val mInfo: AdvertisingIdClient.Info?) {
        @get:UiThread
        val isLimitAdTrackingEnabled: Boolean
            get() = mInfo != null && mInfo.isLimitAdTrackingEnabled

        override fun toString(): String {
            return "AdvertisingInfo{" +
                    "mInfo=" + mInfo +
                    '}'
        }

    }

    companion object {
        private val TAG = ExternalLibrariesMediator::class.java.simpleName
        private val LOGGER =
            INSTANCE.getLogger(LoggerFactory.Type.MISC)

        @UiThread
        private external fun nativeInitCrashlytics()
    }

    init {
        eventLogger = DefaultEventLogger(application)
    }
}